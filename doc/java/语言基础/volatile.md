## 用volatile修饰的变量有以下作用
1. 保证此变量对所有线程是可见的，即指当一条线程修改了这个变量的值，其他线程再次读取将是修改后最新的值。
2. 禁止指令重排序
## 与synchronized的比较
- volatile是一种同步机制，相比synchronized更轻量，因为不会引起线程上下文的切换，即不会阻塞线程。
- 由于volatile 做不到 synchronized关键字的原子保护故只在有限的场景发挥作用。
## 适用场合
1. 如果一个共享变量自始至终只被各个线程赋值，而没有其他的操作，则可以使用volatile。例如：用作一个触发器标志，
用来控制多线程的执行，比如声明一个boolea变量，用volatile修饰，当这个变量为true时，各线程开始真正执行任务。
2. 由于可以禁止指令重排序，可以刷新该变量之前的变量值。
## 不适用场合举例
多线程环境下，对一个volatile变量进行i++的操作，得出结果将小于预期，原因：volatile只保证读取变量是立即可见的，
但i++并不是一个原子操作，会对应多条字节码指令。
## 底层原理
- jvm在编译时，对有volatile变量修饰的共享变量进行赋值操作时，会额外添加一个lock指令，此指令的作用：

    - 将当前处理器缓存行的数据写回到系统内存
    - 使得其他cpu里缓存了该内存地址的数据无效（依赖于缓存一致性协议）